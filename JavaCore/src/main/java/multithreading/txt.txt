Варианты создания нового потока
//Создание
class MyThreadextends Thread{ public void run() { код} }
//Запуск
new MyThread().start();

//Создание
class MyRunnableImplimplements Runnable{ public void run() { код} }
//Запуск
new Thread( new MyRunnableImpl() ).start();
чаще используют 2-ой вариант

Методы Thread:
setName
getName
setPriority
getPriority
sleep
join //говорит main потоку что он должен дождатся окончания выполнения остальных потоков
//приоритетная шкала от 1...10   По дефолту указано 5

Состояние потока -: New -> Runnable (после вызова метода start) -> Terminated (работа потока завершена)
Runnable -: ready (готовность) -> running (когда поток выполняется)

для синхронизации метода используется обьект монитора для обьекта или класса
синхронизация в методе, монитор - это класс (обьект) в котором реализован данный метод
для статичных - это обьект класса, для нестатики - обьект this: проще, есть статика, и не статика, для статики обьект Object, для нестатики this (new Object)
блок синхронизации - указывает монитор this - это обьект класса в котором указан данный метод, или какой-то другой обьект
в блоке можно синхронизировать не весь метод, а его часть
не нужно синхнонизировать конструктор, JVM гарантирует что конструктор в одно и то же время обрабаывается 1м потоком


Монитор –это сущность/механизм, благодаря которому достигается корректная работа при синхронизации.
В Java у каждого класса и объекта есть привязанный к нему монитор.
Пример блока:
static final Object lock = new Object();
public void abc() { method body
synchronized(lock) { block body } method body }

Методы wait и notify
Для извещения потоком других потоков о своих действиях часто используются следующие методы:
wait -освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify();
notify –НЕ освобождает монитор и будит поток, у которого ранее был вызван метод wait();
notifyAll–НЕ освобождает монитор и будит все потоки, у которых ранее был вызван метод wait();


Deadlock –ситуация, когда 2 или более потоков залоченынавсегда, ожидают друг друга и ничего не делают.


Daemon потоки предназначены для выполнения фоновых задач и оказания различных сервисов User потокам.
setDaemon()
isDaemon()
При завершении работы последнего User потока программа завершает своё выполнение, не дожидаясь окончания работы Daemon потоков.

Interruption - это остановка потока.

У нас есть возможность послать сигнал потоку, что мы хотим его прервать - interrupt().
У нас также есть возможность в самом потоке проверить, хотят ли его прервать - isInterrupted().
Что делать, если данная проверка показала, что поток хотят прервать, должен решать сам программист.

Thread pool –это множество потоков, каждый из которых предназначен для выполнения той или иной задачи.
В Java с thread pool-амиудобнее всего работать посредством ExecutorService.
Thread pool удобнее всего создавать, используя factory методы класса Executors:
Executors.newFixedThreadPool(intcount) –создаст pool с 5-ю потоками;
Executors.newSingleThreadExecutor() –создаст pool с одним потоком.
Метод executeпередаёт наше задание (task)в thread pool, где оно выполняется одним из потоков.
После выполнения метода shutdownExecutorServiceпонимает, что новых заданий больше не будет и, выполнив поступившие до этого задания, прекращает работу.
Метод awaitTerminationпринуждает поток в котором он вызвался подождать
 до тех пор, пока не выполнится одно из двух событий: либо ExecutorServiceпрекратит свою работу, либо пройдёт время, указанное в параметре метода awaitTermination.
 ScheduledExecutorServiceмы используем тогда, когда хотим установить расписание на запуск потоков из пула.
 schedule
 Данный pool создаётся, используя factory метод класса Executors:
 Executors.newScheduledThreadPool(intcount)


Callable = Runnable + возможность выбрасывать исключения и возвращать значение. метод run -> теперь метод call
этот интерфейс дженерик типа, нужно указывать, какой тип будет в аутпуте
для Callable вместо метода execute теперь будем использовать метод submit
результат что возвращает Callable хранится в обьекте типа Future
Метод get позволяет получить результат выполнения нашего задания из объекта Future
Runnable можно использовать как с Executor сервисами, так и при отдельном создании Thread.
Callable можно использовать только с Executor сервисами
если нужно чтобы поток возвращал результат - используем Callable, если нет Runnable

Синхронизаторы:
Semaphore –это синхронизатор, позволяющий ограничить доступ к какому-то ресурсу.
В конструктор Semaphore нужно передавать количество потоков, которым
Semaphore будет разрешать одновременно использовать этот ресурс.
acquire()
release()

CountDownLatch–это синхронизатор, позволяющий любому количеству потоков ждать пока не завершится определённое количество операций.
В конструктор CountDownLatchнужно передавать количество операций, которые должны завершится, чтобы потоки продолжили свою работу.
await()
countDown()
getCount()

Exchanger –это синхронизатор, позволяющийобмениваться данными между двумя потоками, обеспечивает то, что оба потока получат информацию друг от друга одновременно.
exchange()

AtomicInteger–это класс, который предоставляет возможность работать с целочисленным значением int, используя атомарные операции.
incrementAndGet() - увеличивает значение на 1 и возвращает значение
getAndIncrement() - сначала возвращает старое значение, потом делает инкремент
addAndGet() - с параметром, на который нужно увеличивать
getAndAdd()
decrementAndGet() - уменьшает значение на 1 и возвращает значение
getAndDecrement()
уменьшить на -5... addAndGet(-5)

Коллекции для работы с многопоточностью:
Synchronized collections - получаются из традиционных коллекций благодаря их обертыванию
Collections.synchronizedXYZ(коллекция) - класс обертка над обычыми однопоточными коллекцими List, Set, Map
используют лок. доступ в коллекцию будет только для 1 потока

Concurrent collections - изначально созданы для работы с многопоточностью
import java.util.concurrent.*;
* ConcurrentHashMap -> {
ConcurrentHashMap имплементирует интерфейс ConcurrentMap, который в свою очередь происходит от интерфейса Map.
В ConcurrentHashMap любое количество потоков может читать элементы не блокируя его.
ConcurrentHashMap,благодаря его сегментированию, при изменении какого-либо элемента блокируется только bucket, в котором он находится.
В ConcurrentHashMapни key, ни value не могут быть null.
}
* CopyOnWriteArrayList -> {
CopyOnWriteArrayListимплементирует интерфейс List.
CopyOnWriteArrayListследует использовать тогда, когда вам нужно добиться потокобезопасности,
у вас небольшое количество операций по изменению элементов и большое количество по их чтению.
В CopyOnWriteArrayListпри каждой операциипо изменению элементов создаётся копия этого листа.
}
* ArrayBlockingQueue -> {
ArrayBlockingQueue–потокобезопаснаяочередь с ограниченным размером (capacity restricted).
Обычно один или несколько потоков добавляют элементы в конец очереди, а другой или другие потоки забирают элементы из начала очереди.
put()
take()
}